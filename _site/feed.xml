<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-09-05T12:15:09-03:00</updated><id>http://localhost:4000/</id><title type="html">Braço Pontilhismo</title><subtitle>Blog dedicado para documentar um projeto que estou desenvolvendo durante meu curso de Engenharia Elétrica na UFRN. A ideia principal do projeto é controlar um braço robótico, através de servo motores, para que consiga desenhar uma imagem qualquer dada através de uma técnica de desenho chamada de pontilhismo.</subtitle><entry><title type="html">Introdução do projeto</title><link href="http://localhost:4000/2018/09/02/introducao-braco.html" rel="alternate" type="text/html" title="Introdução do projeto" /><published>2018-09-02T17:54:42-03:00</published><updated>2018-09-02T17:54:42-03:00</updated><id>http://localhost:4000/2018/09/02/introducao-braco</id><content type="html" xml:base="http://localhost:4000/2018/09/02/introducao-braco.html">&lt;h4 id=&quot;olá-leitor&quot;&gt;Olá leitor!&lt;/h4&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
Este blog será dedicado para documentar um projeto que estou desenvolvendo durante o curso de Engenharia Elétrica na UFRN. A ideia principal é controlar um braço robótico, através de servo motores, para desenhar qualquer imagem utilizando a técnica de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Pontilhismo&quot; target=&quot;_blank&quot;&gt;pontilhismo&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;Imagem 1 - Exemplo da tecninca de pontilhismo
&lt;img src=&quot;/images/introducao-braco/Exemplo-pontilhismo.svg&quot; alt=&quot;Exemplo-pontilhismo&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fonte: LUCCAS BONATO, Pássaro&lt;/p&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
É cada vez mais recorrente o uso de robôs que exercem atividades que geralmente são feitas por humanos. Este projeto tem fim acadêmico, porém, diversas aplicações podem ser geradas a partir desse trabalho, visto a gama de assuntos envolvidos na sua concepção.

Um protótipo foi feito durante o curso de instrumentação eletrônica no pŕimeiro semestre de 2018. Como o blog será sobre a versão melhorada, o protótipo não será abordado tão detalhadamente.
&lt;/p&gt;

&lt;h2 id=&quot;protótipo&quot;&gt;Protótipo&lt;/h2&gt;

&lt;p&gt;Imagem 2 - protótipo&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/introducao-braco/prototipo.svg&quot; alt=&quot;protótipo&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
O protótipo foi construido apenas com &lt;a href=&quot;https://store.arduino.cc/usa/arduino-uno-rev3&quot; target=&quot;_blank&quot;&gt;Arduino Uno Rev3&lt;/a&gt;, 4 servo motores TowerPro SG90 e sua estrutura em MDF. A estrutura em MDF é leve e facilita o controle dela pelos servo motores, pois eles têm baixo torque.
&lt;/p&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
A parte de processamento da imagem foi toda feita em MATLAB. Pega-se a imagem, retira-se os pontos de borda da imagem utilizando &lt;a href=&quot;https://pt.wikipedia.org/wiki/Detector_de_bordas_de_Canny&quot; target=&quot;_blank&quot;&gt;Canny&lt;/a&gt; com o limiar(threshold) escolhido pelo usuário. A partir do resultado anterior é utilizado &lt;a href=&quot;http://cs.joensuu.fi/pages/oili/PR/?a=Some__Material&amp;amp;b=Sequential__Clustering/&quot; target=&quot;_blank&quot;&gt;BSAS&lt;/a&gt; para dar o efeito de espaçamento dos pontos.
&lt;/p&gt;

&lt;h4 id=&quot;bsas&quot;&gt;BSAS&lt;/h4&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
&lt;i&gt;Basic Sequential Algorithmic Scheme&lt;/i&gt; é um algoritimo utilizado principalmente em agrupamento de dados. O algorítimo pode ser resumidamente descrito assim:
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p style=&quot;text-align: justify;&quot;&gt;Escolhe-se um ponto aleatório dos dados para ser o lider do agrupamento;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p style=&quot;text-align: justify;&quot;&gt;Agrupa-se, numa mesma classe, todos os dados que estão próximos dele a uma distância 'ρ' escolhida préviamente;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p style=&quot;text-align: justify;&quot;&gt;Repete-se o passo dois para um novo lider, aleatóriamente escolhido, que não pertence a nenhuma classe até não haver mais nenhum dado sem classe.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;p&gt;Imagem 3 - Base de dados aleatóriamente gerada
&lt;img src=&quot;/images/introducao-braco/dados.svg&quot; alt=&quot;dados&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Imagem 4 - Dados agrupados com ρ=0.7
&lt;img src=&quot;/images/introducao-braco/BSASagrupados.svg&quot; alt=&quot;agrupados&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;processamento-da-imagem&quot;&gt;Processamento da imagem&lt;/h4&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
O que foi utilizado no processamento foi a ideia do BSAS em separar dados de acordo com uma distância. Modificou-se o algoritimo para só memorizar a posição dos lideres, invés de agrupar. Com isso dando uma certa característica de pontilhismo.
&lt;/p&gt;

&lt;p&gt;Imagem 5 - Imagem original&lt;br /&gt;
&lt;img src=&quot;/images/introducao-braco/original.svg&quot; alt=&quot;original&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Imagem 6 - Imagem processada&lt;br /&gt;
&lt;img src=&quot;/images/introducao-braco/bsas.svg&quot; alt=&quot;bsas&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;hardware&quot;&gt;Hardware&lt;/h4&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
Há um problema na parte do hardware pois os servo motores só controlam ângulo dos elos. Então calcula-se a cinemática inversa do braço e seus elos através da notação &lt;a href=&quot;https://pt.wikipedia.org/wiki/Par%C3%A2metros_de_Denavit-Hartenberg&quot; target=&quot;_blank&quot;&gt;Denavit Hartenberg&lt;/a&gt; e simplificações algébricas. Com isso se tem controle sobre o plano XYZ invés de ângulos.
&lt;/p&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
E, por fim, como o pixel é adimensional tem que predefinir o que seria a distância entre um pixel e outro. Utilizou-se a propria bibliotéca do Arduino para controlar cada servo. Para criar o pingo, ou ponto, simplesmente move-se o braço para uma posição acima do papel sem toca-lo. Manda o braço descer, e depois voltar para a posição a cima dele. Repete-se esse movimento toda vez que na imagem processada tiver um pixel branco.
&lt;/p&gt;

&lt;p&gt;Imagem 6 - Resultado&lt;br /&gt;
&lt;img src=&quot;/images/introducao-braco/resultado.svg&quot; alt=&quot;resultado&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: justify;&quot;&gt;
O resultado foi aceitável para o que foi idealizado. Dá para reconhecer a imagem que foi processada. Porém, teve alguns obstáculos e não foram todos resolvidos. Como por exemplo, deslisamento da caneta quando vai criar o ponto. Pretendo resolver isso com sensor de distância nesta nova versão. Mas isso será assunto dos próximos posts.
&lt;/p&gt;

&lt;p&gt;Inté!&lt;/p&gt;</content><author><name></name></author><summary type="html">Olá leitor!</summary></entry></feed>